# 学习笔记
## JS语言通识|泛用语言分类方法
#### 语言按语法分类

- 非形式语言：它的语法没有一个严格的定义。
    - 中文，英文
- 形式语言（乔姆斯基谱系）特点：有一定形式化的定义

乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：
- 0- 型文法（无限制文法或短语结构文法）包括所有的文法。
- 1- 型文法（上下文相关文法）生成上下文相关语言。
- 2- 型文法（上下文无关文法）生成上下文无关语言。
- 3- 型文法（正规文法）生成正则语言。

终结符： 最终在代码中出现的字符（ https://zh.wikipedia.org/wiki/ 終結符與非終結符)

## JS语言通识|什么是产生式
#### 产生式（BNF）
产生式： 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句

巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

终结符： 最终在代码中出现的字符（ https://zh.wikipedia.org/wiki/ 終結符與非終結符)

- 用尖括号括起来的名称来表示语法机构名
- 语法结构分成基础结构和需要用其他语法结构定义的复合结构
  - 基础结构称终结符
  - 符合结构称非终结符
- 引号和中间的字符表示终结符
- 可以有括号
- *表示重复多次
- |表示或
- +表示至少一次

#### 产生式的形式描述及语义–巴斯克范式BNF
- 符号::=表示“定义为”
- 符号|表示“或者是”
- 符号[]表示可缺省

<产生式>::= <前提><结论>

<前提>::=<简单条件>|<复合条件>

<结论>::=<事实>|<操作>

<复合条件>::=<简单条件>AND<简单条件>[AND<简单条件>...|<简单条件>OR<简单条件>]

<操作>::=<操作名>[(<变元>,...)]

四则运算：
- 1+2*3

终结符：
- Number
- +-*/

非终结符：
- MultiplicativeExpression
- AddtiveExpression

BNF

```
<MulltiplicativeExpression>::=<Number>|
    <MulltiplicativeExpression>"*"<Number>|
    <MulltiplicativeExpression>"/"<Number>|
<AddtiveExpression>::=<MulltiplicativeExpression>|
    <AddtiveExpression>"+"<MulltiplicativeExpression>|
    <AddtiveExpression>"-"<MulltiplicativeExpression>|
```


练习：编写带括号的四则运算产生式

四则运算：
- 1 + 2 *（3-1）

终结符：
- Number
- +-*/()

非终结符符：
- MultiplicativeExpression
- AddtiveExpression
- PrimaryExpression

BNF

```
<MulltiplicativeExpression>::=<Number>|
    <MulltiplicativeExpression>"*"<Number>|
    <MulltiplicativeExpression>"/"<Number>|
<AddtiveExpression>::=<MulltiplicativeExpression>|
    <AddtiveExpression>"+"<MulltiplicativeExpression>|
    <AddtiveExpression>"-"<MulltiplicativeExpression>|
<PrimaryExpression>::=<Number>|"("<AddtiveExpression>")"
```
## JS语言通识|深入理解产生式
#### 通过产生式理解乔姆斯基谱系
- 0型 无限制文法
    - ?::=?
- 1型 上下文相关文法
    - ?< A >==?==::=?< B >==?==
- 2型 上下文无关文法
    - < A >::=?
- 3型 正则文法
    - < A >::=< A >?
    - < A >::=?< A > ==x==

JavaScript虽然总体上属于上下文无关文法，其中的表达式部分大部分属于正则文法。但是这里面是有两个特例的，JavaScript的表达式里面有新加了一个**运算符，它是表示乘方，乘方运算符其实它就是右结合的，

比如说2* * 1 * *2;它的结果是2，因为它是右结合的，1 * * 2先运算，所以说1的平方它是1，然后2的一次方它是2；而不是说左边先算，因为是右结合的，所以它并不是一个正则文法；当然if之类的这些语句加上去，那就更不是正则文法了。

JavaScript它也不是一个严格意义上的上下文无关文法，它就有一些特例。比如说我们的get，可以理解为这个东西类似于关键字，我们在定义对象的时候，如果说你在get后面写a跟get后面不写a；它表示的意思是不一样的，如果写a它是个类似关键字的东西；如果在get后面直接冒号，它自己是属性名。

所以我们如果严格是按照乔姆斯基谱系来理解，那么JavaScript其实是属于上下文相关文法。其实乔姆斯基谱系相对来说，它是一个非常学术的定义的方式。

在JavaScript引擎的实现上，你可以理解为它的总体的编程的结构都是一个针对上下文无关文法的这样的一个分析，一旦遇到像get这样的上下文相关的地方，那么就会单独的用代码做一些特例处理。所以一般来说，我们也不会把JavaScript归结为上下文相关文法去处理。虽然说严格意义上来讲，只要有一个特例，那么它就会变成更泛的类型，这就是我们要讲的如何从产生式的角度去理解乔姆斯基谱系。

#### 其它产生式
EBNF ABNF Customized

下面一段例子是JavaScript的标准里面书写产生式的例子，它开头是用缩进来表示的，开头这个相当于产生式左边的非终结符，非终结符后面跟了一个冒号，而之后给了两格的缩进，然后JavaScript的产生式的书写方式，它的非终结符，加号减号这样的，它是用加粗的黑体字来表示它是终结符的，所以说，其实你会发现，你在网上看到的产生式是五花八门的，只学一个BNF是没有办法读懂所有语言的，但是他们尽管有各种各样的不同的书写方法，但是他们所表达的意思大致都是一样的，理解了产生式的背后的思路和原理，是可以忽略这种表达式上的区别的。


```
AdditiveExpression:
    MultiplicativeExpression
    AdditiveExpression +
MultiplicativeExpression
    AdditiveExpression -
MultiplicativeExpression
```

## JS语言通识|现代语言的分类
#### 现代语言的特例
- C++中，*可以表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型。

这个就导致了C++根本就不是形式语言，它是因为要去语义里面去取这个内容，但是其实C+ +整个的语法分析，它本身还是一个形式语言的这样的一个结构，所以说，我们可以知道在现代的编程语言里面，其实并不是非常严格的去贴合着乔姆斯基谱系里面的各个模型去设计的。


- VB中，<可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量

VB和JSX里面都有这个东西

- Python中，行首的tab符合空格会根据上一行的行首空白以一定规则被处理成虚拟终结符indent或者dedent

Python的处理其实就会导致它变成了一个完全的非形式语言，因为任何的形式化定义都没有办法定义上一行行首的概念。所以在Python中虽然还是可以被代码去进行处理，只要处理过了，python就是一个严格的形式化语言，而且是一个上下文无关文法。

所以说在编程语言里面的主体，我们可以认为大部分的编程语言的主体，它都是上下文无关文法。


- JavaScript中，/可能是除号，也可能是正则表达式开头，处理方式类似于VB，字符串模板中也需要特殊处理 }，还有自动插入分号规则。

这些东西都是我们的形式化定义所不能涵盖的，这样其实你会发现大部分主流的流行语言里面，它其实都是有一些边边角角的地方，为了让我们的使用者方便，然后导致编程的时候更加的困难。

#### 语言的分类
- 形式语言——用途
   - 数据描述语言
   - 编程语言

- 形式语言——表达方式
   - 声明式语言
   - 命令型语言

##### 数据描述语言
JSON,HTML,XAML,SQL,CSS

##### 编程语言
C,C++,Java,C#,Python,Ruby,Perl,Lisp,T-SQL,Clojure,Haskell,JavaScript

##### 声明式语言
JSON,HTML,XAML,SQL,CSS,Lisp,Clojure,Haskell

##### 命令型语言
C,C++,Java,C#,Python,Ruby,Perl,JavaScript

练习：尽可能的寻找你知道的计算机语言，尝试把它们分类

- 形式语言——用途
   - 数据描述语言：JSON HTML XAML SQL CSS
   - 编程语言：Java C C++ VB PHP C# Python JavaScript Ruby

- 形式语言——表达方式
   - 声明式语言:JSON HTML XAML SQL CSS
   - 命令型语言:C C++ Java C# Python Ruby JavaScript PHP
   

## JS语言通识|编程语言的性质

- 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。
- 图灵机（Turing machine）：又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。
- 静态和动态语言： https://www.cnblogs.com/raind/p/8551791.html
- 强类型： 无隐式转换
- 弱类型： 有隐式转换
- 协变与逆变： https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html

 
#### 图灵完备性

- 图灵完备性
    - 命令式——图灵机
        - goto
        - if和white
    - 声明式——lambda
        - 递归  

我们所有的编程语言它必备的一个条件就是图灵完备性，最早图灵完备性的提出是由图灵他在研究数学上面的可计算性的时候提出的一个概念。

图灵完备性有几个不同的表达方式，比如说跟图灵机完全等效的就是图灵完备，当然这个定义特别的不直观，它虽然很严格，但是它并不直观。

如果给大家一个直观的这样的描述，就是所有的可计算的问题都可用来描述的这样的语言就是具备图灵完备性的，经历了一代一代的计算机语言的发展，其实图灵完备性逐渐地收敛到了几个固定的模式，所有的命令式语言，基本它是从图灵机理论来的图灵完备性，所以说它实现图灵完备的方式，要么是使用goto语句，要么是使用if语句加while语句，经过一些数学家的证明，goto语句和if加while这两个模式都是可以实现完整的图灵完备性的。

这个声明式语言是来自另一个数学家的成果，叫lambda演算，是邱奇提出来的。lambda演算可以理解为它是数学上定义的一种lambda函数，和我们今天的函数是比较相似的，但是它的基本的意思就是一种替换的关系，lambda演算它可以通过递归来实现图灵完备。

这两位数学家其实都是在很早的时间相继发表的成果，所以在可计算性上面，基本上计算机语言也是有两个流派。一个是用goto,if和while这个流派；另一个是用递归来产生图灵完备性。这两个方式在很多现代的语言里，基本上是两者都支持，所以大家在使用的时候可以经常去判断它们适用的场景，然后选择合适的方式去实现它。

#### 动态与静态
- 动态
   - 在用户的设备/在线服务器上
   - 产品实际运行时
   - Runtime
- 静态
   - 在程序员的设备上
   - 产品开发时
   - Compiletime

动态和静态在计算机这个领域里面术语的意思是什么？给大家一些直观的印象去讲这件事情。

动态其实可以理解为它一定是在用户的设备上去运行的，或者是在在线的服务器上面去运行的，它的运行的时机就是在产品实际的应用运行时，这个动态它基本上对应了一个概念叫Runtime（运行时）。

运行时的概念反过来它也跟我们前面的两个场景是非常的相关联的。

静态最显著的一个特征就是在程序员的设备上运行的，它的时机也是在产品的开发时发生的事情一般来说把它称为静态。比如说静态类型检查就是在你编写这段代码的时候，你就已经可以获得类型的检查了，静态它通常也对应着一个术语叫Compiletime（编译时）。编译时这个也是来自于非常古老的一些编译型语言的一个概念。

从C时代就开始流行Compiletime和Runtime的这样一种对应关系了，像js这种解释执行的语言，其实它没有Compiletime。现在有的也会用Webpack去build一下，但是其实它是没有真正的Compiletime的。

其实今天Runtime和Compiletime的对应已经不准确了，但是我们仍然会愿意沿用Compiletime的习惯，认为JavaScript也是有一个我们在开发时的这样的一个时间，就也会有时候用Compiletime这个词来讲JavaScript的里面的一些特性，所以这就是所谓的动态与静态的区分了。

#### 类型系统
- 动态类型系统与静态类型系统
- 强类型与弱类型
    - String + Number
    - String == Boolean
- 复合类型
    - 结构体
    - 函数签名
- 子类型
- 泛型
    - 逆变/协变

动态类型系统就是在用户的机器上，用户的内存里面能够找到的类型；静态类型系统就是只在程序员编写代码的时候能够保留的类型信息。

典型的动态类型系统，比如说JavaScript就是动态类型系统，我们在写代码里面，可以把这个类型当字符串去取出来。

典型的静态类型系统就是像C++这种，它其实最终编译到目标的机器的代码的时候，所有的类型信息都已经被丢掉了。

所以说我们去区分动态和静态的最简单的办法就是区分它在谁的电脑上能够保留下来。

而像java一样的语言它因为提供了反射机制，所以可以把它称为一种半动态半静态的类型系统。就是在编译时主要的类型检查和类型的操作都已经在编译时被处理掉了，但是如果你想在运行时去获得这个类型的一些信息，你还是可以通过反射去获取的，这个就是一些比较新的语言它们会采取的一种方式。

强类型和弱类型在很多时候常常会跟动态与静态去混淆，其实强类型与弱类型它只是说明在编程语言里类型转换发生的形式。强类型的语言它的类型转换是不会默认发生的。

JavaScript里面它就是一个典型的弱类型语言，最著名的比如说我们用一个string和一个Number相加，JavaScript引擎会默认的把Number转换成string类型，最后给你得到一个string。而像双等号这种它是JavaScript里面一个臭名昭著的失败的一个语言特性，它在string和Boolean之间，如果用双等号运算的话，它会先把Boolean转换成Number，然后再跟String去做是否相同的对比，这是非常奇怪的一个设计。

```
{
    a: T1
    b: T2
}
```
类型往往会产生一些复合类型，比如说我们可以定义一个结构体，定义一个对象，那么它的a属性它必须得属于类型T1 。

```
（T1,T2）=> T3
```

有一些函数，因为像JavaScript语言它函数是可以作为参数传递的，所以这些函数也有一个类型，我们一般称作函数签名。函数签名包含参数类型和返回值类型两个部分，参数类型它又是一个列表，所以说函数类型它可能就会有T1、T2然后变成T3这样的一种形式。

子类型典型的语言就是C++,它会有这样子类型的一个概念，所有的基于类的面向对象的语言它都会把类的机构关系变成类型的关系，注意类跟类型其实是两个概念。有了子类型的概念，所以说在做类型转换的时候，它就会有一些默认的行为，比如说能用父类型的地方，它都能用子类型。

泛型，在一些语言里面现在又多了一种范式，叫做泛型编程，还可以把这个类型当做一个参数一样的东西，去传递给我们的某一段代码机构，然后才有可能这个代码结构有可能是类，也有可能是函数，分别对应着泛型类和泛型函数。然后泛型和子类型相结合，就会产生逆变、协变这样的东西。

例子：凡是能用Array<Parent>的地方，都能用Array<Child>

凡是能用Function<Child>的地方，都能用Function<Parent>

其实在类型论里面，类型推导和像逆变、协变加上子类型、复合类型，这些结构上面一直是有一些未解的难题的，所以我们对于类型可以有一个大致的了解，因为JavaScript其实是一个弱类型的系统，但是这些知识如果你在学习TS的时候，都是会有一些用处的。

## JS语言通识|一般命令式编程语言的设计方式
#### 一般命令式编程语言

- Atom(原子)
    - Identifier（关键字）
    - Literal（直接量）
- Expression（表达式）
    - Atom
    - Operator
    - Punctuator
- Statement
    - Expression
    - Keyword
    - Punctuator
- Structure
    - function
    - Class
    - Process
    - Namespace
    - ...
- Program
    - Program
    - Module
    - Package
    - Library

原子级是一个语言的最小的组成单位，它通常包含着一些关键字，包含一些直接量，包含着一些变量名这样的一些节本的单位。这种基本的单位就是原子，典型的就是我们的变量名和我们写一个1234这样的字符串直接量或者是数字直接量

这些原子级的这些结构通过运算符相连接，然后加上一些辅助的符号，那么它就会构成一个表达式的结构，表达式通常是一个可以级联的结构.

在前面讲产生式的时候，也给大家以四则运算为例，让大家简单了解了一下表达式的这种形态，复杂的语言可能有10多层的表达式，
比如说JavaScript，它就有除了四则运算，又有按位与，移位运算、比较运算、又有或、非这些逻辑运算，它有一个非常复杂的结构。

表达式，它加上一些特定的标识符，和一些特定的关键字和一些特定的符号形成一定的结构，我们把它叫做语句，这个表达式呢它本身，我们一般的语言里面，都会有一个叫做表达式语句的东西，这就是设计表达式跟语句的这样的一个连接的这样的一个点，然后这个语句呢，就是大家比较熟悉的if这种条件语句，可能有while和for这种循环语句，它在这个里面都会在它的不同的部分用到表达式。

其实一个有语句的语言已经是一个可以达成图灵完备并且去执行的语言了，一般语言在上面还有两个层级，一个叫做结构化的层级，比如说JavaScript里面，它就会有function，class这样的一些设计，它是帮助我们去组织代码，把代码分成不同的块，然后分成不同的复用的结构，那么同时同样的它也会使用像关键字来形成这种结构化的结构，然后JavaScript里面没有的，像process，比如说古老的语言PASCAL，通常被用做教科书的这一门语言，就会有process的语言所谓的过程，然后有一些语言里面，还会有namespace这样的东西，比如C++里就会有namespace。

然后更上面一个层级通常是用来组织代码的，这个呢有的语言有，有的不在语言里面，在一些辅助性的设施里面，Program，Module，Package等这些概念能够帮助我们去更好的管理语言的模块和安装，在JavaScript里面，我们现在通常做着一个角色的是npm，JavaScript本身也有两个最顶级的定义，一个叫program，一个叫module，module就是准备好被复用的模块，program应该就是实际执行的代码了，两者之间在JavaScript里面做了严格的区分，也有一些语言根本就不区分，像java里面它就会有package这个概念，有些语言里则用library这个概念。

总之，我们就会从这5个层级的这样的角度去讲解JavaScript语言，对每个层级的讲解的方式都会有一个固定的结构。

```
graph LR
语法-->|语义|运行时
```
## JS类型|Number

#### Atom原子
##### Grammar
- Literal
- Variable
- Keywords
- Whitespace
- Line Terminator

##### Runtime
- Types
- Execution Context

首先看语法部分，上面这些都是组成JavaScript语言的一个最小的元素，这是通过我们的这种字面值，比如说我们表示一个数字类型的字面值1234，然后在配合上我们的变量，然后在配合上一些if else 关键字，以及一些符号；另外还有空白符、换行符它们虽然不会产生实际的语言上的作用，但是可以帮助我们去让整个语言的格式更好看一些。而这些东西实际上最终反映到运行时。

字面值重点是它的类型，因为其实有五六种字面值的写法，它对应到JavaScript的7种基本类型中的几种，另外就是变量实际上对应到运行时的Execution Context里面的一些存储的变化，最终其实这些语法都会造成一个运行时的改变，怎么改变的就是语义的部分，就是重点的部分。

#### Types
- Number
- String
- Boolean
- Object
- Null(有值，但是为空)
- Undefined(没有定义)
- Symbol
- (BigInt)

前5种是编程中常用的，值得一提的是Null在早期JavaScript设计的时候，出现了一点偏差，它的typeof值最后会出来一个Object。这个是JavaScript一个早期的设计bug。

#### Number
- IEEE 754 Double Float(双精度浮点类型)
    - Sign (1) 
    - Exponent (11)
    - Fraction (52)

在计算机领域里，Float表示浮点数，意思是它的小数点是可以来回浮动的，它的基本思想就是我们把一个数字拆成它的指数和有效位数。这个数的有效位数是决定了浮点数表示的精度，这个指数决定了浮点数表示的范围。

所以说浮点数可以表示很大的数，但是数越大，它能表示的位置它就越稀疏。比如我们在接近最大值的时候，它其实可能不是每个整数都能表示了，一般不会这么用。

浮点数它会有一个最大的整数表示范围，几乎很少会越最大的整数表示范围的界，然后浮点数还有一个可以表示的符号，它有可以表示正负，这又占了一位，最终IEEE754的浮点数，双精度浮点数表示是1个符号位加上11个指数位，再加上52个精度位表示的，每一个位就是一个bit，它可以是0或者1。

#### Number-Grammar
- DecimalLiteral
    - 0
    - 0.
    - .2
    - 1e3
- BinaryIntegerLiteral
    - 0b111
- OctallIntegerLiteral
    - 0o10    
- HexIntegerLiteral
    - 0xFF

0.toString()

因为0.是一个合法的十进制的语法，所以0.会当成一个0，后面再接toString就出错了。

0 .toString()

正确写法0空格.toString()，这样toString的点就会被理解为取属性的运算符

## JS类型|String
#### String
- Character
- Code Point
- Encoding

```
graph LR
A[a]-->B[97]
B-->C[0110001]
```
            

string在英文里面的原意是串成一串的这种链子。比如中国古代的一串铜钱。那一串就是一个string。

在计算机领域里这个字符串里面当然串的就是字符了，字符在英文里就叫character，Character就是一个字符，但是字符在计算机里是没法表示的，我们认为字符其实是一个抽象的表达，还要结合字体才会变成一个可见的形象。

计算机里是用Code Point 来表示 Character，Code Point简单来说就是一个数字，比如说咱们就规定97代表a ，以后只要结合一定的类型信息，咱们就可以通过97和字体里面的信息，把a 找出来，也可以把它画到屏幕上，然后下一个问题就是97怎么存？

计算机里面存储的单位是字节

#### String
字符集
- ASCII
- Unicode
- UCS
- GB
    - GB2312
    - GBK(GB13000)
    - GB18030
- ISO-8859
- BIG5

很多资料里把JavaScript的Code Point给它叫做ASCII码，早年确实因为字符数数量比较少，所以说咱们就把字符的编码都叫做ASCII码，但其实是不对的。

ASCII码它只规定了127个字符，这127个字符就是咱们计算机里最常用的127个字符包括26个大写字母，26个小写字母，数字0-9以及各种制表符，各种特殊的符号，换行这些控制字符，总共用了127个，那么它就用0~127来表示。但是这个显然就没有办法来表示中文了。

ASCII字符集是最早美国计算机先发明出来的一种编码方式，所以只照顾到了英文，而后来大家建立了一个标准，叫做Unicode把全世界的各种字符全都给它粘到一起去，形成一个大合集。所以才叫Unicode联合的编码集。

Unicode它的字符的数量非常的大，然后还划成了各种片区，最终形成了一个Unicode的庞大的编码集。而Unicode这个里面早年大家觉得0000~FFFF，FFFF就已经够了，两个字节觉得这已经能表现的太多了，后来发现还不够用，所以这个也造成了一些设计上的问题，有一些软件一想两个字节就够了是吧，那我干脆就浪费一点空间，就两个字节占满，但是后来发现两个字节不够用，

所以基于两个字节的编码，就是Unicode里面的0000~FFFF，是Unicode和另一个标准化组织发生合并的时候，产生了一个叫UCS的这样的一个字符集，UCS它就只有0000~FFFF这样的一个范围的字符集。

GB国标其实经历了几个年代，2312是国标的第一个版本，也是大家非常的广泛使用的一个版本。国标跟Unicode比，有个特点就是字符集它不一致，同样一个中文字，国标里的字符码点跟Unicode里面的码点不一致，但是这两个以及后来的所有几乎世界上所有的编码格式都会去兼容ASCII，因为ASCII真的非常早，它是计算机的一个基础，所以有的时候就会造成一些概念上的误解，不管你用哪个编码都感觉这个字符的编码它就应该是ASCII码。

后来出了一个扩充就是GBK，GBK本来也是以为够用了，它其实也有个国标的号，GB13000；后来又出了一个真正意义上的大全的版本，就是GB18030，这个是补上了几乎所有缺失的字符，这也是各行各业大家都会有一些缺字符的烦扰。

国标跟Unicode不兼容，但是国标也有一定的好处，就是国标的范围毕竟小，相应的来说，同样的一组中文，你用GB编码它肯定要比用Unicode的某种编码格式要省空间。

跟国标类似的有ISO-8859系列的，一堆东欧国家，都把自己国家的语言设计成了类似GB这样的一种在ASCII上扩展了，8859系列它们都跟ASCII的兼容，但是它们互不兼容，8859不是一个统一的标准。

台湾这个情况跟国标类似，它们一般用的是BIG5俗称大五码，然后其实国标ISO-8859系列和BIG5系列，它们的性质非常的像，都属于一定的国家地区语言的特定的编码格式，它们互相之间是冲突的，码点占的都是重的，所以没有办法混合使用。

#### String-Encoding
- UTF

UTF8 

默认用一个字节表示一个字符，所有的ASCII字符在UTF-8里面它都是属于ASCII字符，它的编码方式是兼容的，一段ASCII码编码的文字它同事也一定是一个UTF-8编码的这样的一段文字，反过来不成立，因为它叫默认用一个字节，不是说所有的字符都是用一个字节，比如有中文ASCII的编码方式那就累死了也编不出来。
```
graph LR
01100001-->a
```
```
graph LR
01100010-->b
```
UTF16

默认用16个比特位，也就是两个字节来表示一个字符，比如ASCII字符集里的a它就会在前面补一个全是0的这样的一位，b也是在前面补一个全是0的这样的一个8位，这样最后它默认就占了16个比特位
```
graph LR
0000000001100001-->a
```
```
graph LR
0000000001100010-->b
```
练习：去写一段JS的函数把一个string它代表的字节给它转换出来？用utf8对字符串进行编码
```
function UTF8_Encoding(string){
    //return new Buffer();
}
```
#### String-Grammar
"abc"


'abc'

`abc`反引号

早年的JavaScript支持两种写法：第一种是双引号字符串，第二种是单引号字符串，没什么区别，仅仅是单双引号的使用下，双引号里面可以加单引号作为普通字符，单引号可以加双引号作为普通字符。所以两种是完全等效的。

里面有一些特殊字符是不能用的，比如说回车不能用怎么办，它就规定了一个\n来表示，Tab符可以用，还是规定了\t来表示。

双引号的字符串里面还想用双引号，也是在前面加个反斜杠，没有特殊含义的这些字母，前面加反斜杠都是它自身，比如\a它就是a，两个反斜杠连着就表示一个正常的反斜杠字符，这是字符串里面的一个微语法。

然后到了后面的版本比较新的JavaScript版本，就加了反引号的版本，就是1键左边的，而反引号不太常用，正因为它不太常用，所以说它非常适合做语法的这样的一个结构。

这种反引号字符串就厉害了，里面又可以回车，又可以干嘛，特别是里面可以插$符开始的这种变量，$符和花括号这样的变量的结果，这样它就是一个比较强大的一个字符串直接量的写法，只要里面你不用反引号，随便加什么都行。

练习：尽量用写一个正则表达式去匹配单引号和双引号的字符串的写法？

## JS类型|其他类型
#### Boolean
- true
- false

都是关键字

#### Null & Undefined
- null 关键字
- undefined
- void 0;

```
function f(){
    var undefined = 1；
    console.log(undefined);//1
}
```

```
function f(){
    var null = 0;
    console.log(null);//抛出错误
}
```
用void 0来产生undefined，因为void运算符是个关键字，void后面不管跟什么，它都会把后面表达式的值变成Undefined这个值，所以说在语法上最简洁的得到Undefined的值的方法就是使用void关键字来进行一次运算。

## JS对象|对象的基础知识
三要素：唯一标识，状态，行为

## JS对象|JS中的对象
JavaScript中的对象其实它只有两个要素，一个是Property，就是它的属性，一个对象它是一个属性的集合，另外就是JavaScript的每一个对象它都有一个Prototype。

众所周知，属性可以用来描述状态，而JavaScript其实它的属性既可以用来描述状态，也可以用来描述行为，因为JavaScript的函数也是可以放进属性里面的，所以这两个状态和行为得以统一，至于唯一标识性JavaScript用内存地址，我们绝大多数编程语言都是用内存地址的唯一性来表示对象的唯一性的。

JavaScript里面原生支持了一个原型机制，当我们去找一个对象属性的时候，如果它自身不包含属性，那么它就会去它的原型里去找，如果它的原型的原型不是空的话，那么它还会继续往它的原型的原型上去找，所以这个就形成了一个链式的行为，所以我们会把JavaScript里面的原型描述为原型链。

正是因为JavaScript的获取属性的行为，它是会沿着原型的指向一路向上找过去，一直找到原型为Nihilo也就是Null的这样的一个原型对象。

#### 属性

```
graph LR
Symbol-->Data
```
```
graph LR
String-->Accessor
```
JavaScript的属性是一个KV对，所谓kv对应该是大家在平时工作中，遇到的很多的一种数据结构，它的特点是我们可以根据K找到这个V。

JavaScript的K值可以是两种类型，一种是symbol，一种是string；string是一个可以去猜出来的一种K，不管你在string上写的有多奇怪，只要别人看到你的源代码，那么他就可以从任何一个地方拿到这个对象实例之后，他总能访问到你的属性。

而symbol不一样，它在内存里创建了之后，它就只能通过变量去引用它，没有办法构造两个一模一样的symbol，这个特性倒是跟对象有一点相似，所以两个symbol即使它们的名字一样，它们也是不相等的，这样symbol就很好的实现了属性访问的权限控制，如果你不把symbol的名字传递给下一家，那么你的编写的代码的使用者他是没有办法去访问你用symbol名字作为K的属性值的。

Data Property
- [[value]]
- writable
- enumerable
- configurable

JavaScript的属性的值的部分有两种形态，一种是数据属性，一种是访问器属性。

数据属性是非常简单的，它符合我们正常意义上的一种对数据属性的认知，那么数据属性首先有一个具体存储的值，那么它可以是任何的JavaScript的值，也就是我们的7种类型之一，都没有问题，同时呢，一个数据属性有一个writable的attribute，attribute其实我们在很多场景下也会翻译成属性，但是因为在这里Property是真正的属性，

在JavaScript标准中就会认为属性的这些value writable enumerable configurable都是属于attribute，它是属性的一种特征值，那么它这个数据属性它可以有是否可写的特征值。也可以有是否可枚举的特征值，以及是否可以被改变的这样的一个特征值，

当你把configurable设为false之后，configurable enumerable value writable都变的不可更改了。writable其实可以去，但是当我们把writable false的时候，我们仅仅是通过点运算不可更改，我们仍然可以通过define Property去修改writable它的特征值。这样我们可以强行把这个数据变得可更改。

Accessor Property
- get
- set
- enumerable
- configurable

Accessor Property至少要有get和set之一，这两个都是JavaScript的函数，这两个特征值就是在我们用点去访问属性，读的时候和写的时候，分别去调用的，那么它也有configurable enumerable；enumerable主要影响的是Object.keys()这样的一些内置的函数的行为，它也会影响forEach这样的语法产生的默认的行为，那么访问器属性多数时候它都是用来描述行为的，但是有的时候访问器属性，同时会描述状态和行为，

数据属性如果存储函数那么也可以用于描述行为，这个在JavaScript里面是比较自由的，有的时候我们在数据属性里存了一个函数，但是本身这个函数跟对象一点关系都没有，这样也是可以的，那么这个时候其实这个函数就是一种数据，而当这个数据属性中存储一个函数，然后这个函数本身里面去访问对象自身的一些数据的时候，那么我们认为它这个时候表示的是行为。

## Object API/Grammar
- {} . [] Object.defineProperty
- Object.create/Object.setPrototypeOf/Object.getPrototypeOf
- new/class/extends
- new/function/prototype

第一组属性它们提供了一个基本的对象机制，那么我们能够通过语法去创建对象，访问属性和定义新的属性，以及去改变属性的特征值，这个是基本的面向对象能力。

第二组属性是基于原型的描述对象的方法，通过Object.create在制定原型的前提下创建对象，而我们有可以去修改一个对象的原型，或者获取一个对象的原型，这组叫基于原型的对象API。

第三组是新的语法结构，它们是用来以基于分类的方式去描述对象，而这种基于分类的方式，尽管它在运行时仍然会变转换成JavaScript的原型相关的访问，但是我们从语法上来看，从它的抽象能力上来看，它完全就是一个基于类的这样的面向对象的组织方式。

最后一组是一个历史包袱，这种方式是不伦不类的，长得有点像Class base，但是其实里面还是需要一些prototype的知识才能够完成面向对象的抽象的，所以最后一组建议大家就不要用。

前三种除了基础的部分，其实包含两个模式，一种是基于原型的，一种是基于类的，那么他们都是非常好的面向对象的一种描述方式。

## Function Object
